# SQL
## 1 уровень
### Форматирование SQL запроса
Задание на форматирование кода SQL запроса. То есть сотруднику нужно плохо и некрасиво написанный код отформатировать таким образом, чтобы он стал более читаемым, понятным и простым к восприятию. Например:
- Добавить отступы для каждого уровня вложенного запроса;
- Делать прозрачные и понятные алиасы;
- Добавить комментарии в код для увеличения прозрачности логики кода;
- Разделить пустой строкой разные логические участки кода;
- Избавиться от явных дублей кода там, где это возможно (Принцип DRY - Don't repeat yourself).

Таким образом удастся **сформировать культуру** написания кода, что является лучшей практикой других больших компаний.

### Масштабирование и переиспользование
**Сделать какой-либо скрипт "масштабируемым"**
То есть написать такой запрос, который не будет вести себя непредсказуемо с увеличением данных, а будет отрабатывать также правильно с увеличением выборки, на которой были предыдущие запросы.
В качестве задания можно на выбор:
* Устно спросить отличия масштабируемого кода, от немасштабируемого;
* Переписать готовый запрос таким образом, чтобы он стал масштабируемым:
	* Убрать ненужные поля из запроса, что может сделать запрос оптимальнее;
	* Убрать сортировки и обработки там, где это ненужно; 
	* Ограничивать объем возвращаемого результата, если не нужен весь объем.
* Написать подобный запрос с нуля.

**Сделать скрипт "переиспользуемым"**
То есть свести к минимуму хард-код (жестко зашитые константы внутри запроса, оставив только там, где это необходимо).
В качестве задания можно на выбор:
- Устно спросить отличия кода, который можно переиспользовать, и нельзя;
- Переписать готовый код таким образом, чтобы его можно было переиспользовать, а именно:
	- Убрать жестко зашитые константы там, где это не нужно
	- Убрать жесткую привязку к структуре данных (прописать `toString()`, или `toUInt64()` там, где это нужно, чтобы исключить ошибки)
- Написать подобный запрос с нуля.

## 2 уровень
### Оперирование различными типами данных
Нужно задание, которое поможет понять, знает ли сотрудник ключевые особенности различных типов данных и применяет ли их особенности на практике. Для это можно использовать на выбор:
- Устный опрос про типы данных;
- Заполнение теста по типам данных, где будет список вопросов о достоинствах и недостатках того или иного типа данных;
- Переписать код таким образом, чтобы использовались ровно те типы данных, которые будут наиболее оптимальны. Например, 
	- для чисел, от 0 до 255 использовать тип `Int8`, 
	- для дат без необходимости отчета часов использовать тип `Date`, 
	- если нужны часы, но без миллисекунд - `DateTime`, чтобы не использовать нули в записи даты.
- Написать подобный запрос с нуля

### Работа с JSON
Умение сотрудника использовать JSON в своей работе, и знание основных принципов его использования, составления и извлечения. 
Для этого можно использовать задания на выбор:
- Преобразования массива в JSON  с помощью `toJSONString()`;
- Извлечение массива из JSON с помощью `JSONExtract()`;
- Составление "*кастомного*" JSON с несколькими полями с помощью `map()`;
- Извлечение данных из конкретного поля внутри "кастомного" JSON;

### Работа окнами, with и join
**Оконные функции**
Для оценки знаний сотрудника по уровню владения оконными функциями можно использовать такие задачи, как:
- Добавить порядковый номер для каждого встреченного дубля в таблице по конкретному полю
- Посчитать активное время сотрудника
- Посчитать, среднее общее время для каждого сотрудника

**with - CTE**
По сути, это заранее подготовленные таблицы, или другие данные, с которыми можно работать. Значит можно попросить решить задачу с использованием CTE:
- Найти топ 5 человек с наибольшим объемом отработанных часов
- Найти суммарную продолжительность отработанного времени для сотрудников с использованием with

**join**
Для того, чтобы узнать уровень знания разных типов join можно:
- Попросить устно описать типы join-ов
- Использовать в коде **left** или **right** join-ы, и описать, для чего они нужны:
	- Присоединение справочников с использованием any или без
- Использовать **cross join**
	- Создание пар всех  доступных полей одной таблицы 
- Использовать **asof join**
	- Соединение по времени

